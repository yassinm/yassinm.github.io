<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yassin Mohamed</title>
    <link>http://yassinm.github.io/</link>
    <description>Recent content on Yassin Mohamed</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Â© 2019, Yassin Mohamed; all rights reserved.</copyright>
    <lastBuildDate>Sun, 10 Sep 2017 11:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://yassinm.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Wiring data transformations for speed (part 2)</title>
      <link>http://yassinm.github.io/2017/wiring-data-transformations-for-speed-02/</link>
      <pubDate>Sun, 10 Sep 2017 11:00:00 +0000</pubDate>
      
      <guid>http://yassinm.github.io/2017/wiring-data-transformations-for-speed-02/</guid>
      <description>If you remember our previous article we highlighted some of the inherent complexities we introduce by writing code the way we do today. We also stopped at a very few high level because frankly speaking this was going to be a very long read if we did not stop ranting about the current state of affairs :((</description>
    </item>
    
    <item>
      <title>Wiring data transformations for speed (part 1)</title>
      <link>http://yassinm.github.io/2017/wiring-data-transformations-for-speed-01/</link>
      <pubDate>Sat, 09 Sep 2017 11:00:00 +0000</pubDate>
      
      <guid>http://yassinm.github.io/2017/wiring-data-transformations-for-speed-01/</guid>
      <description>If you think about our software industry today all we do , day in and day out, is &amp;ldquo;transform&amp;rdquo; data from one state to another. The systems we have in place today can be seen , at a very high level, as black boxes that take a variable number of arguments as inputs and produce a well defined output</description>
    </item>
    
    <item>
      <title>Walking down memory lane (part 3)</title>
      <link>http://yassinm.github.io/2014/walking-down-memory-lane-03/</link>
      <pubDate>Mon, 06 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yassinm.github.io/2014/walking-down-memory-lane-03/</guid>
      <description>If you remember our previous article we used a central memory location to share data between two separate threads each running either in the same process or across separate processes.</description>
    </item>
    
    <item>
      <title>Walking down memory lane (part 2)</title>
      <link>http://yassinm.github.io/2014/walking-down-memory-lane-02/</link>
      <pubDate>Thu, 25 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yassinm.github.io/2014/walking-down-memory-lane-02/</guid>
      <description>As per our previous article we identified that we need a way to serialize objects into memory in a very efficient manner. To recap here is a picture showing the steps we need to remove when sending/receiving objects over the network.</description>
    </item>
    
    <item>
      <title>Walking down memory lane (part 1)</title>
      <link>http://yassinm.github.io/2014/walking-down-memory-lane-01/</link>
      <pubDate>Sun, 21 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://yassinm.github.io/2014/walking-down-memory-lane-01/</guid>
      <description>One of the topics that you often have to deal with in java, especially in high performance and low latency distributed code, is how you send a set of objects to a worker thread in the most efficient manner.</description>
    </item>
    
    <item>
      <title>Starting to blog ... finally</title>
      <link>http://yassinm.github.io/2013/first-post/</link>
      <pubDate>Sat, 13 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>http://yassinm.github.io/2013/first-post/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>