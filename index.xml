<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yassin Mohamed</title><link>http://yassinm.github.io/</link><description>Recent content on Yassin Mohamed</description><generator>Hugo -- gohugo.io</generator><language>en-ca</language><copyright>Copyright Â© 2019, Yassin Mohamed; all rights reserved.</copyright><lastBuildDate>Sun, 10 Sep 2017 11:00:00 +0000</lastBuildDate><atom:link href="http://yassinm.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Wiring data transformations for speed (part 2)</title><link>http://yassinm.github.io/2017-09-10-wiring-data-transformations-for-speed-02/</link><pubDate>Sun, 10 Sep 2017 11:00:00 +0000</pubDate><guid>http://yassinm.github.io/2017-09-10-wiring-data-transformations-for-speed-02/</guid><description>If you remember our previous part 1 article we highlighted some of the inherent complexities we introduce by writing code the way we do today. We also stopped at a high level because (frankly speaking) this was going to be a very long read. We had to stop ranting about the current state of affairs :((
In that article, we came to the conclusion that maybe we needed a way to remove those unnecessary complexities and deal with them outside the data flow graph to achieve maximum flexibility and speed.</description></item><item><title>Wiring data transformations for speed (part 1)</title><link>http://yassinm.github.io/2017-09-09-wiring-data-transformations-for-speed-01/</link><pubDate>Sat, 09 Sep 2017 11:00:00 +0000</pubDate><guid>http://yassinm.github.io/2017-09-09-wiring-data-transformations-for-speed-01/</guid><description>If you think about our software industry today all we do , day in and day out, is &amp;ldquo;transform&amp;rdquo; data from one state to another. The systems we have in place today can be seen , at a very high level, as black boxes that take a variable number of arguments as inputs and produce a well defined output
The purpose of all programs, and all parts of those programs, is to transform data from one form to another.</description></item><item><title>Walking down memory lane (part 3)</title><link>http://yassinm.github.io/2014-10-06-walking-down-memory-lane-03/</link><pubDate>Mon, 06 Oct 2014 00:00:00 +0000</pubDate><guid>http://yassinm.github.io/2014-10-06-walking-down-memory-lane-03/</guid><description>If you remember our previous part 2 article we used a central memory location to share data between two separate threads each running either in the same process or across separate processes. These processes could even be located on separate machine or even be written in two different languages.
From the above you can see that we only have one thread writing to the shared data. The other thread is only reading this shared data once it is notified that the data was correctly published by the writer thread.</description></item><item><title>Walking down memory lane (part 2)</title><link>http://yassinm.github.io/2014-09-25-walking-down-memory-lane-02/</link><pubDate>Thu, 25 Sep 2014 00:00:00 +0000</pubDate><guid>http://yassinm.github.io/2014-09-25-walking-down-memory-lane-02/</guid><description>As per our previous part 1 article we identified that we need a way to serialize objects into memory in a very efficient manner. To recap here is a picture showing the steps we need to remove when sending/receiving objects over the network.
FTR we are still not interested in solving how these troublesome bytes are transferred over the network from one process to another once the data is ready to be transferred.</description></item><item><title>Walking down memory lane (part 1)</title><link>http://yassinm.github.io/2014-09-21-walking-down-memory-lane-01/</link><pubDate>Sun, 21 Sep 2014 00:00:00 +0000</pubDate><guid>http://yassinm.github.io/2014-09-21-walking-down-memory-lane-01/</guid><description>One of the topics that you often have to deal with in java, especially in high performance and low latency distributed code, is how you send a set of objects to a worker thread in the most efficient manner. This thread could be running in the same process or on a completely separate machine located somewhere else in your network. This has always been the case for people coming from a c/c++ environment even before the advent of Java.</description></item><item><title>Starting to blog ... finally</title><link>http://yassinm.github.io/2013-07-13-first-post/</link><pubDate>Sat, 13 Jul 2013 00:00:00 +0000</pubDate><guid>http://yassinm.github.io/2013-07-13-first-post/</guid><description/></item></channel></rss>