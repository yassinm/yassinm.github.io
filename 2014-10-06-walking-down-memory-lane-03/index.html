<!doctype html><html class=dark lang=en-ca><head><meta http-equiv=content-type content="text/html" charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-X51Z9ZSVTG"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-X51Z9ZSVTG')</script><link rel=stylesheet href=/css/main.min.3187593a6422ad33b7d2164db7fdee7e49f51043413d4fe2b01f2e596c1e0215.css integrity=sha256-MYdZOmQirTO30hZNt/3ufkn1EENBPU/isB8uWWweAhU=><script type=text/javascript src=/js/fonts.min.f8952214762921b4f64b73e2957b35e4d15f86bd8df6dba030b5f9d531681c67.js></script></head><body class=dark:bg-gray-800><div class="min-h-screen bg-gray-100"><div class=py-10><div class="max-w-3xl mx-auto sm:px-6 lg:max-w-7xl lg:px-8 lg:grid lg:grid-cols-12 lg:gap-8"><div class="hidden lg:block lg:col-span-3 xl:col-span-2"><nav aria-label=Sidebar class="sticky top-4 divide-y divide-gray-300"><div class="pb-8 space-y-1"><a href=http://yassinm.github.io class="bg-gray-200 text-gray-900 group flex items-center px-3 py-2 text-sm font-medium rounded-md" aria-current=page><svg class="text-gray-500 flex-shrink-0 -ml-1 mr-3 h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0 7-7 7 7M5 10v10a1 1 0 001 1h3m10-11 2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/></svg><span class=truncate>Home</span></a>
<a href=# class="text-gray-600 hover:bg-gray-50 group flex items-center px-3 py-2 text-sm font-medium rounded-md"><svg class="text-gray-400 group-hover:text-gray-500 flex-shrink-0 -ml-1 mr-3 h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975.0 0120 13a7.975 7.975.0 01-2.343 5.657z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z"/></svg><span class=truncate>Popular</span></a></div><div class=pt-10><p class="px-3 text-xs font-semibold text-gray-500 uppercase tracking-wider" id=communities-headline>Tags</p><div class="mt-3 space-y-2" aria-labelledby=communities-headline><a href=http://yassinm.github.io/tags/dataflow/ class="group flex items-center px-3 py-2 text-sm font-medium text-gray-600 rounded-md hover:text-gray-900 hover:bg-gray-50"><span class=truncate>dataflow</span></a></div><div class="mt-3 space-y-2" aria-labelledby=communities-headline><a href=http://yassinm.github.io/tags/memory/ class="group flex items-center px-3 py-2 text-sm font-medium text-gray-600 rounded-md hover:text-gray-900 hover:bg-gray-50"><span class=truncate>memory</span></a></div></div></nav></div><div class="lg:col-span-8 xl:col-span-8"><div class="flex flex-col rounded-lg shadow-lg overflow-hidden"><div class="flex-1 bg-white p-6 flex flex-col justify-between"><div class="flex-1 mx-auto"><p><a href=http://yassinm.github.io/2014-10-06-walking-down-memory-lane-03/ class="text-2xl font-bold font-inter text-gray-500">Walking down memory lane (part 3)</a></p><div class="mt-8 prose"><p>If you remember our previous <a href=http://yassinm.github.io/2014-09-25-walking-down-memory-lane-02/>part 2 article</a> we used a central memory location to share data between two separate threads each running either in the same process or across separate processes. These processes could even be located on separate machine or even be written in two different languages.</p><p><img src=/images/walking-down-memory-lane-03-000.png alt=Fig1></p><p>From the above you can see that we only have one thread writing to the shared data. The other thread is only reading this shared data once it is notified that the data was correctly published by the writer thread. Now the question is how do these threads synchronize access to this shared memory location with minimal contention ?</p><h2 id=lock-free-rings-to-the-rescue>Lock free rings to the rescue</h2><p>If we need to access this data concurrently we need to let the two separate threads agree (more like synchronize) access based on a locking mechanism. The trick here is to piggy back on the memory model provided by the processor. The cache coherency on x86 systems provides a happens-before guaranty when the data in a certain memory location is modified. However, if the memory is written using the <a href=https://mechanical-sympathy.blogspot.ca/2011/09/single-writer-principle.html>Single Writer Principle</a> that data is not propagated forcibly each time a write occurs to invalidate other caches. This basically means that, If the publishing thread writes to this memory location the other thread(s)/core(s) will see this change at some time in the future (and anything that happened before it) without impeding or affecting the publishing thread. As such, the publishing thread can keep updating that location. For the gory details i will point you to this article on <a href=https://mechanical-sympathy.blogspot.ca/2013/02/cpu-cache-flushing-fallacy.html>CPU Cache</a> and this one on <a href=https://mechanical-sympathy.blogspot.ca/2011/07/memory-barriersfences.html>memory barriers and fences</a>.</p><p><img src=/images/walking-down-memory-lane-03-001.png alt=Fig2></p><p>As can be seen above the two threads behaviour looks, conceptually, like a reservoir with one thread filling it from the top while the other thread is draining it. The memory is treated as a single contiguous stream of data with each message having a unique incrementally sequential location. The reader thread knows that the messages coming down the pipe have the same size and are all numbered in a sequential manner and keeps track of the last message position that was fetched from the pipe (head). On the other hand, the publishing thread also knows the sequence number of the last message written to the pipe (tail). Both sequences are augmented incrementally and independently via lock free based mechanism. The algorithm for inserting new elements in this queue must enforce a limit since we only have a very finite space for storing things. Ergo the notion of a circular ring buffer. The writer thread needs to make sure no new elements are inserted when the circular ring buffer is full. On a similar note, the reader thread also makes sure that if there are no new elements added since the last fetch it can spin lock waiting for new elements to be inserted. This algorithm is said to be lock free but not necessarily wait free. Meaning that we can bail out and go do other things when the queue is full/empty , making thus the algorithm practically wait free, or if there is nothing else to do we can do a spin lock until the situation is resolved. Meaning we lose the wait free portion but we are still lock free. From a pendantic point of view an algorithm is called lock free when progress is guaranteed for the system as a whole but not necessarily for each thread.</p><p>One can easily imagine how this buffer can be seen by multiple reader threads with one single publisher making broadcast or parallel type messaging. It is only a matter of adding more head/tail addresses and managing that accordingly when we are adding/removing items in the queue. Once the messages are read by multiple consumer threads they can all act on the same data in a parallel fashion or each consumer thread can be responsible for only part of the sequences based on a partitioning scheme. One particular partitioning technique championed by the <a href=http://lmax-exchange.github.io/disruptor/>Disruptor</a> is to use a modulo for each reader so that for example odd sequence messages are handled by one reader while the others are handled by another reader. But we still get the same benefits in that the actual data will be paged by the kernel and available right away without incurring unnecessary cache misses. Once a block of data is written to memory we could use something like transferTo to finally achieve a zero copy like network <a href=https://www.ibm.com/developerworks/linux/library/j-zerocopy/>transfer</a> in Java while the publishing thread continues to write new data on a new location. the fact remains that each particular reader thread is effectively free to do what it pleases with the block of data without waiting or synchronizing with other threads.</p><p>Furthermore, as we said before, the consumer thread can be anything that can access this memory locations sequentially. This scheme can be used to not only communicate with lower level c/c++ code (or any code written in any language for that matter) but it can also be used to send data directly to GPUs running on the same machine. Once a sufficient amount of data is written by the thread publishing this block of data it can be copied over using DMA over the graphic processing card for example. The same obviously goes for sending/receiving data over high speed NIC cards or proprietary high speed transports.</p><h2 id=lets-share-some-data->Lets share some data !</h2><p>I uploaded the code for this article on <a href=https://github.com/yassinm/blog.mlane.000>github</a>. The application is using shared memory mapped files for the memory location. When i run the publisher and subscriber for a 50Million 8 byte (long) one way message stream (from publisher to subscriber only) on a AWS m3.2xlarge instance i am consistently getting ~140 Million messages per second. The test is repeated for 30times and averaged. On my AMD 4 core laptop i am getting a mere 13M messages per second. This is before we start talking about thread affinity and cpu isolation. If you can run this code on your own hardware give me a shout!</p></div></div></div></div></div></div></div></body></html>